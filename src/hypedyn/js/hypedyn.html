<html>
<head></head>

<body>
	<div id="node_display"></div>
	<div id="fact_debug"></div>
	<center><canvas id="myCanvas" width="250" height="60"></center>
</body>
</html>

<script src="datastructure.js"></script>
<script src="hashtable.js"></script>
<script src="dynfile.js"></script>
<script src="facts.js"></script>
<script src="rules.js"></script>
<script language="javascript">
	
	var startNodeID;
	var currNodeID;
	function gotoNode(nodeID) {
		//var node = nodelist.get(nodeID);
		var node = nodelist[nodeID];
		if (node != undefined) {
			
			// event trigger
			eventTrigger("enteredNode", node);
			for (var i in node.links) {
				eventTrigger("enteredNode", node.links[i]); 
			}
			
			node.visited = true;
			currNodeID = nodeID;
			
			trigger_anywhere_check ();
			
			var htmlcode = htmlFormat(node.content, node.links);
			document.getElementById("node_display").innerHTML = htmlcode;
		}
	}

	function clickedLink(linkID) {
		if (linklist[linkID] != undefined) {
			linklist[linkID].followed += 1;
			eventTrigger("clickedLink", linklist[linkID]);
		}
	}
	
	// replace text works as follows
	// eventTrigger("nodeEntered", link) trigger all the replaceText that is suppose to fire
	// replaceText place a pair of linkID and content into text_to_replace
	// in htmlFormat use findReplaceText(linkID) to find out whether the link need replacing or not
	// text_to_replace is emptied for next time
	var text_to_replace = [];
	function replaceText(linkID, altcontent) {
		function comparator ( pair1, pair2 ) {
			pair1[0] < pair2[0];
		}
		insertSorted( text_to_replace, [linkID, altcontent], comparator );
		//text_to_replace[text_to_replace.length] = [linkID, altcontent];
	}
	function findReplaceText(linkID) {
		var result;
		for (var i in text_to_replace)
			if (text_to_replace[i][0] == linkID) {
				// need to differentiate between 
				// text from fact or just text
				if (typeof text_to_replace[i][1] == "string")
					result = text_to_replace[i][1];
				else if (typeof text_to_replace[i][1] == "integer")
					result = factlist[text_to_replace[i][1]].value;
				else result = "[Text Replace Error]";
			}
		return result;
	}
	
	var activated_anywhere_nodes = [];
	
	// anywhere link stub TODO:
	function addAnywhereLink(anywhereNodeID) {
		activated_anywhere_nodes[activated_anywhere_nodes.length] = nodelist[anywhereNodeID];
	}
	
	function anywherelink_htmlcode () {
		var result = "";
		for ( i in activated_anywhere_nodes ) {
			if (activated_anywhere_nodes[i].id != currNodeID) {
				result += "<a href='javascript:void(0)' onClick='gotoNode(" 
					+ activated_anywhere_nodes[i].id + ")'>"
					+ activated_anywhere_nodes[i].name + "</a><br>"
			}
		}
		return result;
	}
	
	function trigger_anywhere_check () {
		activated_anywhere_nodes = [];  // reset
		for ( i in nodelist ) {
			if (nodelist[i].anywhere == true)
				// triggering the rule with the addAnywhereLink action to fire if condition true
				eventTrigger("anywhereCheck", nodelist[i]); 
		}
	}
	
	function setStartNode(snodeID) {
		startNodeID = snodeID;
	}
	
	// look for \n char and attach a </text><br><text>
	function processNewline( str ) {
		
	}

	// here we need to add anywhere node 
	function htmlFormat(content, links) {

		// start is the current link ID available through links[start]
		// offset is where have we parsed till in content
		function helper(index, offset) {
			var start = false;
			if (links[index] != undefined)
				start = links[index].start;
			else start = content.length; // hack to signal that all links are shown
			
			if (offset == content.length) return "";
			else if (start > offset) { // print the text before the link
				return "<text>"+content.substring(offset, start)+"</text>"+ helper(index, start);
			} else if (start == offset) { // print the link
				// note not to confuse index with link id
				// index is just the order at which it appears in the node and the position in the text
				var currLink = links[index];
				var end = currLink.end;
				var altcontent = findReplaceText(currLink.id);
				var linktext;
				if (altcontent == undefined)
					linktext = content.substring(start, end);
				else 
					linktext = altcontent;

				// NOTE: there is no rules with no actions, 
				// the export process to javascript code will makes sure that's true
				if (currLink.rules.length > 0)
					return "<a href='javascript:void(0)' onClick='clickedLink(" + currLink.id + ")'>"
						+ linktext
						+"</a>" + helper(index+1, end);
				else return "<text>" + linktext + "</text>" + helper(index+1, end);
			} else { // start < offset
				alert("error in htmlFormat");
			}
		}
		var htmlcode = helper(0, 0) + "<br><br>" + anywherelink_htmlcode();
		text_to_replace = []; // clear for next run
		return htmlcode;
	}
	
	function runhypedyn() {
		if (typeof startNodeID == "undefined") alert("Start Node not set!");
		else gotoNode(startNodeID);
	}
	
	//
	//    Canvas Drawing
	//
	
	function drawPageIndicator(pagenum) {
		var canvas = document.getElementById("myCanvas");
		var gcontext = canvas.getContext("2d");
		
		var half_height = canvas.height / 2;
		var width = canvas.width;
		var radius = half_height * 0.15;
		
		
		function drawCircle(context, cx, cy, r) {
			context.beginPath();
			context.arc(cx, cy, r, 0, 2 * Math.PI, false);
			context.closePath();
			
			context.fillStyle = "#8ED6FF";
			context.fill();
		
			//context.lineWidth = 2;
			//context.strokeStyle = "black";
			//context.stroke();
		}
		
		// tl - top left, br - btm right
		function drawRect(context, tlx, tly, brx, bry) {
			context.beginPath();
			context.rect(tlx, tly, brx, bry);
			context.lineWidth = 1;
			context.strokeStyle = "black";
			context.stroke();
		}
		
		drawCircle(gcontext, width/4 *1, half_height, radius);
		drawCircle(gcontext, width/4 *2, half_height, radius);
		drawCircle(gcontext, width/4 *3, half_height, radius);
		drawRect(gcontext, 0, 0, canvas.width, canvas.height);
	}	
	
	window.onload = function() {
		loadStory();
		runhypedyn();
		factsDebug();
		drawPageIndicator(0);
	}

</script>